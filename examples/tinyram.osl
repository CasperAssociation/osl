-- 16-bit, 8-register TinyRAM 2.0 VM

def todo : Prop := 0N = 1N.

data Word ~= Fin(65536).

def zero : Word := to(Word)(fin(0)).

data Register ~= Fin(8).

data Opcode ~= Fin(32).

def opAnd    : Opcode := to(Opcode)(fin(0)).
def opOr     : Opcode := to(Opcode)(fin(1)).
def opXor    : Opcode := to(Opcode)(fin(2)).
def opNot    : Opcode := to(Opcode)(fin(3)).
def opAdd    : Opcode := to(Opcode)(fin(4)).
def opSub    : Opcode := to(Opcode)(fin(5)).
def opMull   : Opcode := to(Opcode)(fin(6)).
def opUmulh  : Opcode := to(Opcode)(fin(7)).
def opSmulh  : Opcode := to(Opcode)(fin(8)).
def opUdiv   : Opcode := to(Opcode)(fin(9)).
def opUmod   : Opcode := to(Opcode)(fin(10)).
def opShl    : Opcode := to(Opcode)(fin(11)).
def opShr    : Opcode := to(Opcode)(fin(12)).
def opCmpe   : Opcode := to(Opcode)(fin(13)).
def opCmpa   : Opcode := to(Opcode)(fin(14)).
def opCmpae  : Opcode := to(Opcode)(fin(15)).
def opCmpg   : Opcode := to(Opcode)(fin(16)).
def opCmpge  : Opcode := to(Opcode)(fin(17)).
def opMov    : Opcode := to(Opcode)(fin(18)).
def opCmov   : Opcode := to(Opcode)(fin(19)).
def opJmp    : Opcode := to(Opcode)(fin(20)).
def opCjmp   : Opcode := to(Opcode)(fin(21)).
def opCnjmp  : Opcode := to(Opcode)(fin(22)).
def opStoreb : Opcode := to(Opcode)(fin(26)).
def opLoadb  : Opcode := to(Opcode)(fin(27)).
def opStorew : Opcode := to(Opcode)(fin(28)).
def opLoadw  : Opcode := to(Opcode)(fin(29)).
def opRead   : Opcode := to(Opcode)(fin(30)).
def opAnswer : Opcode := to(Opcode)(fin(31)).

data Bool ~= Fin(2).

def true  : Bool := to(Bool)(fin(1)).
def false : Bool := to(Bool)(fin(0)).

data Immediate ~= Word.

data Arg1 ~= Register.

data Arg2 ~= Register.

data Arg3 ~= Register + Immediate.

data Instruction ~= Opcode * Arg1 * Arg2 * Arg3.

def getOpcode : Instruction -> Opcode
  := \x : Instruction => pi1(from(Instruction)(x)).

def isStore : Instruction -> Prop
  := \x : Instruction
  => let o : Opcode := getOpcode(x);
     (o = opStoreb) | (o = opStorew).

def isLoad : Instruction -> Prop
  := \x : Instruction
  => let o : Opcode := getOpcode(x);
     (o = opLoadb) | (o = opLoadw).

def getArg1 : Instruction -> Register
  := \x : Instruction => from(Arg1)(pi1(pi2(from(Instruction)(x)))).

def getArg2 : Instruction -> Register
  := \x : Instruction => from(Arg2)(pi1(pi2(pi2(from(Instruction)(x))))).

def getArg3 : Instruction -> (Register + Immediate)
  := \x : Instruction => from(Arg3)(pi2(pi2(pi2(from(Instruction)(x))))).

data Address ~= Word.

data Memory ~= Address -> Word.

def getMemoryValue : Memory -> Address -> Word
  := \m : Memory => \a : Address
  => from(Memory)(m, a).

data Program ~= Address -> Instruction.

def getProgramInstruction : Program -> Address -> Instruction
  := \p : Program => \a : Address
  => from(Program)(p, a).

data RegisterValues ~= Register -> Word.

data Flag ~= Bool.

data ProgramCounter ~= Address.

data InitialState ~= Memory * Program.

def getMemory : InitialState -> Memory
  := \s : InitialState => pi1(from(InitialState)(s)).

def getProgram : InitialState -> Program
  := \s : InitialState => pi2(from(InitialState)(s)).

data Time ~= Fin(4096).

def isBefore : Time -> Time -> Prop
  := \t0 : Time => \t1 : Time
  => (cast(from(Time)(t0)) +N 1N) <= cast(from(Time)(t1)).

data StoredWord ~= Word.

data LinkedTime ~= Time.

data LinkedValue ~= Word.

data Step ~=
    ProgramCounter
  * Instruction
  * RegisterValues
  * Flag
  * Address
  * StoredWord
  * LinkedTime
  * LinkedValue.

def getProgramCounter : Step -> Address
  := \s : Step => from(ProgramCounter)(pi1(from(Step)(s))).

def getStepInstruction : Step -> Instruction
  := \s : Step => pi1(pi2(from(Step)(s))).

def getRegisterValues : Step -> RegisterValues
  := \s : Step => pi1(pi2(pi2(from(Step)(s)))).

def getRegisterValue : Step -> Register -> Word
  := \s : Step => \r : Register
  => (from(RegisterValues)(getRegisterValues(s)))(r).

def getFlag : Step -> Flag
  := \s : Step => pi1(pi2(pi2(pi2(from(Step)(s))))).

def getAddress : Step -> Address
  := \s : Step => pi1(pi2(pi2(pi2(pi2(from(Step)(s)))))).

def getStoredWord : Step -> Word
  := \s : Step => from(StoredWord)(pi1(pi2(pi2(pi2(pi2(pi2(from(Step)(s)))))))).

def getLinkedTime : Step -> Time
  := \s : Step => from(LinkedTime)(pi1(pi2(pi2(pi2(pi2(pi2(pi2(from(Step)(s))))))))).

def getLinkedValue : Step -> Word
  := \s : Step => from(LinkedValue)(pi2(pi2(pi2(pi2(pi2(pi2(pi2(from(Step)(s))))))))).

def getArg3Value : Step -> Word
  := \s : Step
  => ((\r : Register => getRegisterValue(s, r))
       + (\i : Immediate => from(Immediate)(i)))
       (getArg3(getStepInstruction(s))).

data Trace ~= List^4096(Step).

def getSteps : Trace -> List^4096(Step)
  := \T : Trace => from(Trace)(T).

def getStep : Trace -> Time -> Step
  := \T : Trace => \t : Time
  => nth(getSteps(T), cast(from(Time)(t))).

def isFirstStepAccessingGivenAddress : Time -> Step -> Prop
  := \t : Time => \s : Step
  => t <= getLinkedTime(s).

-- Checks that the given function, assumed to be a function
-- defined on the times [0,n), is a permutation.
-- TODO: replace this with a more efficient permutation argument,
-- by augmenting Sigma^1_1 formulas with a quantifier over permutations.
def isStepPermutation : N -> (Time -> Time) -> Prop
  := \n : N => \p : Time -> Time
  => all i : N < n, some j : N < n,
     let it : Time := to(Time)(cast(i));
     let jt : Time := to(Time)(cast(j));
     p(jt) = it.

def linksAreOrdered : Trace -> Prop
  := \T : Trace
  => let ss : List^4096(Step) := getSteps(T);
     some finalAccesses : Address ->^4096 Time,
     let p : Time -> Time := \t : Time => getLinkedTime(getStep(T, t));
     isStepPermutation(length(ss), p)
   & (all i : N < length(ss),
      let s : Step := nth(ss, i);
      let t : Time := to(Time)(cast(i));
      let t' : Time := getLinkedTime(s);
      let a : Address := getAddress(s);
      (t' = finalAccesses(a))
    | isBefore(t', t)).

def doesNotAnswerPrematurely : Trace -> Prop
  := \T : Trace
  => let ss : List^4096(Step) := getSteps(T);
     all i : N < length(ss),
     let s : Step := nth(ss, i);
     ((i +N 1N) = length(ss))
   | !(getOpcode(getStepInstruction(s)) = opAnswer).

def transition : Step -> Step -> Prop
  := \s0 : Step => \s1 : Step
  => todo.

def transitions : Trace -> Prop
  := \T : Trace
  => let ss : List^4096(Step) := getSteps(T);
     all i1 : N < length(ss),
     (i1 = 0N)
   | (some i0 : N < length(ss), ((i0 +N 1N) = i1)
    & transition(nth(ss, i0), nth(ss, i1))).

def initialConditions : Trace -> Prop
  := \T : Trace
  => let ss : List^4096(Step) := getSteps(T);
     (0N = length(ss))
   | (let s : Step := nth(ss, 0N);
      (getProgramCounter(s) = to(Address)(zero))
    & (getFlag(s) = to(Flag)(false))
    & (all r : Register, getRegisterValue(s, r) = zero)).

def traceIsValid : Trace -> Prop
  := \T : Trace
  => linksAreOrdered(T)
   & doesNotAnswerPrematurely(T)
   & transitions(T)
   & initialConditions(T).

def traceAccepts : Trace -> Prop
  := \t : Trace
  => let ss : List^4096(Step) := getSteps(t);
     some i : N < length(ss),
     ((i +N 1N) = length(ss))
   & (let s : Step := nth(ss, i);
      (getOpcode(getStepInstruction(s)) = opAnswer)
    & (getArg3Value(s) = to(Word)(fin(0)))).

def memoryIsConsistentWithTrace : Memory -> Trace -> Prop
  := \M : Memory => \T : Trace
  => let ss : List^4096(Step) := getSteps(T);
     all i : N < length(ss),
     let s : Step := nth(ss, i);
     let t : Time := to(Time)(cast(i));
     (isFirstStepAccessingGivenAddress(t, s) & isStore(getStepInstruction(s)))
     -> (getStoredWord(s) = getMemoryValue(M, getAddress(s))).

def programIsConsistentWithTrace : Program -> Trace -> Prop
  := \P : Program => \T : Trace
  => let ss : List^4096(Step) := getSteps(T);
     all i : N < length(ss),
     let t : Time := to(Time)(cast(i));
     let s : Step := nth(ss, i);
     getStepInstruction(s) = getProgramInstruction(P, getProgramCounter(s)).

def programAccepts : InitialState -> Prop
  := \i : InitialState
  => some t : Trace,
     let m : Memory := getMemory(i);
     let p : Program := getProgram(i);
     traceIsValid(t)
   & traceAccepts(t)
   & memoryIsConsistentWithTrace(m, t)
   & programIsConsistentWithTrace(p, t).
