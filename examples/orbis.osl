data Byte ~= Fin(256).

data ByteString ~= List^8192(Byte).

data Datum ~= ByteString.

data Redeemer ~= ByteString.

data F ~= Fin(4096).

def bytesPerWord : N := 8N.

data PubKeyHash ~= F.

data Time ~= F.

data ValidRange ~= Time * Time.

data MintQuantity ~= Z.

data CurrencySymbol ~= F.

data TokenName ~= F.

data AssetClass ~= CurrencySymbol * TokenName.

data Mint ~= Map^128(AssetClass, MintQuantity).

data Quantity ~= F.

data Value ~= Map^128(AssetClass, Quantity).

data Fee ~= Value.

data Address ~= F.

data ScriptAddress ~= F.

data RootOut ~= Address * Value.

data TxOut ~= Address * (Value * Maybe(Datum * Redeemer * ScriptAddress)).

data TxId ~= Time * F.

data RootOutRefIndex ~= F.

data TxOutRefIndex ~= F.

data RootOutRef ~= Time * RootOutRefIndex.

data TxOutRef ~= TxId * TxOutRefIndex.

data LeafOut ~= TxOutRef + RootOutRef.

data RootIn ~= RootOutRef * RootOut.

data SpendIn ~= TxOutRef + RootOutRef.

data RefIn ~= TxOutRef + RootOutRef.

data MintInputs ~= Map^8(CurrencySymbol, Datum * Redeemer).

data Signatories ~= List^128(PubKeyHash).

data Tx ~=
    List^128(SpendIn)
  * List^128(RefIn)
  * List^128(TxOut)
  * Fee
  * Mint
  * MintInputs
  * ValidRange
  * Signatories.

data Unit ~= Fin(1).

def unit : Unit := to(Unit)(fin(0)).

data Rollup ~=
    Map^4096(TxId, Tx)
  * Map^4096(Time, List^128(RootOut))
  * Map^4096(LeafOut, Unit).

def spendingInputs : Tx -> List^128(SpendIn)
  := \t : Tx => pi1(from(Tx)(t)).

def referenceInputs : Tx -> List^128(RefIn)
  := \t : Tx => pi1(pi2(from(Tx)(t))).

def outputs : Tx -> List^128(TxOut)
  := \t : Tx => pi1(pi2(pi2(from(Tx)(t)))).

def fee : Tx -> Fee
  := \t : Tx => pi1(pi2(pi2(pi2(from(Tx)(t))))).

def mint : Tx -> Mint
  := \t : Tx => pi1(pi2(pi2(pi2(pi2(from(Tx)(t)))))).

def mintInputs : Tx -> MintInputs
  := \t : Tx => pi1(pi2(pi2(pi2(pi2(pi2(from(Tx)(t))))))).

def validRange : Tx -> ValidRange
  := \t : Tx => pi1(pi2(pi2(pi2(pi2(pi2(pi2(from(Tx)(t)))))))).

def signatories : Tx -> Signatories
  := \t : Tx => pi2(pi2(pi2(pi2(pi2(pi2(pi2(from(Tx)(t)))))))).

def txs : Rollup -> Map^4096(TxId, Tx)
  := \r : Rollup => pi1(from(Rollup)(r)).

def roots : Rollup -> Map^4096(Time, List^128(RootOut))
  := \r : Rollup => pi1(pi2(from(Rollup)(r))).

def leaves : Rollup -> Map^4096(LeafOut, Unit)
  := \r : Rollup => pi2(pi2(from(Rollup)(r))).

def txOutRefId : TxOutRef -> TxId
  := \r : TxOutRef => pi1(from(TxOutRef)(r)).

def txIdTime : TxId -> Time
  := \i : TxId => pi1(from(TxId)(i)).

def txOutRefIndex : TxOutRef -> TxOutRefIndex
  := \r : TxOutRef => pi2(from(TxOutRef)(r)).

def rootOutRef : RootIn -> RootOutRef
  := \i : RootIn => pi1(from(RootIn)(i)).

def rootOut : RootIn -> RootOut
  := \i : RootIn => pi2(from(RootIn)(i)).

def rootOutRefTime : RootOutRef -> Time
  := \r : RootOutRef => pi1(from(RootOutRef)(r)).

def rootOutRefIndex : RootOutRef -> RootOutRefIndex
  := \r : RootOutRef => pi2(from(RootOutRef)(r)).

def txOutAddress : TxOut -> Address
  := \o : TxOut => pi1(from(TxOut)(o)).

def value : TxOut -> Value
  := \o : TxOut => pi1(pi2(from(TxOut)(o))).

def values : List^128(TxOut) -> List^128(Value)
  := \vs : List^128(TxOut) => List(pi1)(List(pi2)(List(from(TxOut))(vs))).

def scriptInfo : TxOut -> Maybe(Datum * (Redeemer * ScriptAddress))
  := \o : TxOut => pi2(pi2(from(TxOut)(o))).

def currencySymbol : AssetClass -> CurrencySymbol
  := \a : AssetClass => pi1(from(AssetClass)(a)).

def tokenName : AssetClass -> TokenName
  := \a : AssetClass => pi2(from(AssetClass)(a)).

def start : ValidRange -> Time
  := \r : ValidRange => pi1(from(ValidRange)(r)).

def end : ValidRange -> Time
  := \r : ValidRange => pi2(from(ValidRange)(r)).

def feeValue : Fee -> Value := from(Fee).

def mintValue : Mint -> Map^128(AssetClass, MintQuantity) := from(Mint).

def valueMap : Value -> Map^128(AssetClass, Quantity) := from(Value).

def mintInputsMap : MintInputs -> Map^8(CurrencySymbol, Datum * Redeemer)
  := from(MintInputs).

def getSignatories : Signatories -> List^128(PubKeyHash)
  := from(Signatories).

def getQuantity : Quantity -> N
  := \x : Quantity => cast(from(F)(from(Quantity)(x))).

def getMintQuantity : MintQuantity -> Z
  := from(MintQuantity).

def makeCurrencySymbol : ScriptAddress -> CurrencySymbol
  := \a : ScriptAddress => to(CurrencySymbol)(from(ScriptAddress)(a)).

def fromScriptAddress : ScriptAddress -> Address
  := \a : ScriptAddress => to(Address)(from(ScriptAddress)(a)).

def fromPubKeyHash : PubKeyHash -> Address
  := \h : PubKeyHash => to(Address)(from(PubKeyHash)(h)).

def txOutToLeaf : TxOutRef -> LeafOut
  := \r : TxOutRef => to(LeafOut)(iota1(r)).

def rootOutToLeaf : RootOutRef -> LeafOut
  := \r : RootOutRef => to(LeafOut)(iota2(r)).

def datumSize : Datum -> N
  := \d : Datum => length(from(ByteString)(from(Datum)(d))).

def datumSizes : List^128(Datum) -> List^128(N)
  := \ds : List^128(Datum) => List(length)(List(from(ByteString))(List(from(Datum))(ds))).

def redeemerSize : Redeemer -> N
  := \r : Redeemer => length(from(ByteString)(from(Redeemer)(r))).

def redeemerSizes : List^128(Redeemer) -> List^128(N)
  := \rs : List^128(Redeemer) => List(length)(List(from(ByteString))(List(from(Redeemer))(rs))).

data Minting ~= CurrencySymbol.

data Spending ~= TxOutRef.

data ScriptPurpose ~= Minting + Spending.

data ScriptContext ~= Tx * ScriptPurpose.

def makeContext : (Tx * ScriptPurpose) -> ScriptContext := to(ScriptContext).

def minting : CurrencySymbol -> ScriptPurpose
  := \s : CurrencySymbol => to(ScriptPurpose)(iota1(to(Minting)(s))).

def spending : TxOutRef -> ScriptPurpose
  := \r : TxOutRef => to(ScriptPurpose)(iota2(to(Spending)(r))).

data Steps ~= N.

data ScriptSize ~= N.

def accepts
  : ScriptAddress
  -> ScriptSize
  -> Steps
  -> Datum
  -> Redeemer
  -> ScriptContext
  -> Prop
  := \a : ScriptAddress => \sz : ScriptSize => \s : Steps
  => \d : Datum => \r : Redeemer => \c : ScriptContext
  => 0N = 0N. -- TODO: make this a free variable.

data Frac ~= N.

def precision : N := 32N.

def toFrac : N -> Frac
  := \x : N => to(Frac)(precision *N cast(x)).

def maxFrac : Frac := toFrac(576460748008456192N).

def add : Frac -> Frac -> Frac
  := \x : Frac => \y : Frac
  => to(Frac)(from(Frac)(x) +N from(Frac)(y)).

def isProd : Frac -> Frac -> Frac -> Prop
  := \x : Frac => \y : Frac => \z : Frac
  => (precision *N from(Frac)(z))
   = (from(Frac)(x) *N from(Frac)(y)).

def roundsUpTo : Frac -> N -> Prop
  := \x : Frac => \y : N
  => (from(Frac)(x) <= (precision *N y))
   & ((cast(precision *N y) +Z ((-1Z) *Z cast(from(Frac)(x))))
      <= (cast(precision) +Z (-1Z))).

def txOutListSize : List^128(TxOut) -> N
  := \x : List^128(TxOut)
  => let txdata : List^128(Maybe(Datum * Redeemer * ScriptAddress))
       := List(pi2)(List(pi2)(List(from(TxOut))(x)));
     let datums : List^128(Maybe(List^8192(Byte)))
       := List(Maybe(from(ByteString)))
            (List(Maybe(from(Datum)))
              (List(Maybe(pi1))(txdata)));
     let redeemers : List^128(Maybe(List^8192(Byte)))
       := List(Maybe(from(ByteString)))
            (List(Maybe(from(Redeemer)))
              (List(Maybe(pi1))(List(Maybe(pi2))(txdata))));
     (2N *N bytesPerWord *N length(x))
  +N sum(List(Maybe(length))(datums))
  +N sum(List(Maybe(length))(redeemers)).

def spendInListSize : List^128(SpendIn) -> N
  := \x : List^128(SpendIn)
  => bytesPerWord +N ((1N +N (3N *N bytesPerWord)) *N length(x)).

def refInListSize : List^128(RefIn) -> N
  := \x : List^128(RefIn)
  => bytesPerWord +N ((1N +N (3N *N bytesPerWord)) *N length(x)).

def valueSize : Value -> N
  := \x : Value
  => bytesPerWord +N (3N *N bytesPerWord *N length(keys(from(Value)(x)))).

def mintSize : Mint -> N
  := \x : Mint
  => bytesPerWord +N (3N *N bytesPerWord *N length(keys(from(Mint)(x)))).

def mintInputsSize : MintInputs -> N
  := \x : MintInputs
  => let x' : Map^8(CurrencySymbol, Datum * Redeemer)
       := from(MintInputs)(x);
     let datums : Map^8(CurrencySymbol, List^8192(Byte))
       := Map(from(ByteString))(Map(from(Datum))(Map(pi1)(x')));
     let redeemers : Map^8(CurrencySymbol, List^8192(Byte))
       := Map(from(ByteString))(Map(from(Redeemer))(Map(pi2)(x')));
     bytesPerWord +N ((3N *N bytesPerWord) *N length(keys(x')))
       +N sumMapLength(datums)
       +N sumMapLength(redeemers).

def signatoriesSize : Signatories -> N
  := \x : Signatories
  => 2N *N bytesPerWord *N length(from(Signatories)(x)).

def feeSize : Fee -> N
  := \x : Fee
  => valueSize(from(Fee)(x)).

def txSize : Tx -> N
  := \x : Tx
  => (4N *N bytesPerWord)
  +N spendInListSize(spendingInputs(x))
  +N refInListSize(referenceInputs(x))
  +N txOutListSize(outputs(x))
  +N feeSize(fee(x))
  +N mintSize(mint(x))
  +N mintInputsSize(mintInputs(x))
  +N signatoriesSize(signatories(x)).

data A ~= Frac.

data B ~= Frac.

data C ~= Frac.

data F0 ~= Frac.

data M ~= Frac.

data FeePaymentAddress ~= Address.

data FeeParams ~= A * B * C * F0 * M * FeePaymentAddress.

def a : FeeParams -> Frac
  := \x : FeeParams => from(A)(pi1(from(FeeParams)(x))).

def b : FeeParams -> Frac
  := \x : FeeParams => from(B)(pi1(pi2(from(FeeParams)(x)))).

def c : FeeParams -> Frac
  := \x : FeeParams => from(C)(pi1(pi2(pi2(from(FeeParams)(x))))).

def f0 : FeeParams -> Frac
  := \x : FeeParams => from(F0)(pi1(pi2(pi2(pi2(from(FeeParams)(x)))))).

def m : FeeParams -> Frac
  := \x : FeeParams => from(M)(pi1(pi2(pi2(pi2(pi2(from(FeeParams)(x))))))).

def feePaymentAddress : FeeParams -> FeePaymentAddress
  := \x : FeeParams => pi2(pi2(pi2(pi2(pi2(from(FeeParams)(x)))))).

def noScriptInfo : Maybe(Datum * Redeemer * ScriptAddress)
  := nothing.

def paysFeeToCorrectAddress : FeeParams -> Tx -> Prop
  := \p : FeeParams => \t : Tx
  => some i : N < length(outputs(t)),
     let o : TxOut := nth(outputs(t), i);
     let f : Map^128(AssetClass, Quantity) := from(Value)(feeValue(fee(t)));
     (txOutAddress(o) = from(FeePaymentAddress)(feePaymentAddress(p)))
   & (all i : N < length(keys(f)),
      let k : AssetClass := nth(keys(f), i);
      lookup(k, f) = lookup(k, from(Value)(value(o)))).

def checkCost : FeeParams -> Tx -> List^128(ScriptSize * Steps) -> Frac -> Prop
  := \p : FeeParams
  => \t : Tx
  => \s : List^128(ScriptSize * Steps)
  => \x : Frac
  => let scriptSizeAgg : N := from(ScriptSize)(sum(List(pi1)(s)));
     let sumSteps : N := sum(List(from(Steps))(List(pi2)(s)));
     some d : Frac < maxFrac,
     some e : Frac < maxFrac,
     some f : Frac < maxFrac,
       isProd(a(p), toFrac(txSize(t)), d)
     & isProd(b(p), toFrac(scriptSizeAgg), e)
     & isProd(c(p), toFrac(sumSteps), f)
     & (x = add(d, add(e, f))).

def feeRequirementMet
   : FeeParams
  -> Tx
  -> List^128(ScriptSize * Steps)
  -> N
  -> Prop
  := \p : FeeParams
  => \t : Tx
  => \s : List^128(ScriptSize * Steps)
  => \x : N
  => paysFeeToCorrectAddress(p, t)
   & (f0(p) <= toFrac(x))
   & (some c : Frac < maxFrac,
      some d : Frac < maxFrac,
      some e : N,
      (e <= x)
    & checkCost(p, t, s, c)
    & isProd(m(p), c, d)
    & roundsUpTo(d, e)).


def txExists : Rollup -> TxId -> Prop
  := \R : Rollup => \i : TxId
  => !(isNothing(lookup(i, txs(R)))).


def inputExists : Rollup -> TxOutRef + RootOutRef -> Prop
  := \R : Rollup => \x : TxOutRef + RootOutRef
  => (some y : TxOutRef, (x = iota1(y))
    & ((1N +N cast(from(F)(from(TxOutRefIndex)(txOutRefIndex(y)))))
        <= maybe((\t : Tx => length(outputs(t))))(
                 0N,
                 lookup(txOutRefId(y), txs(R)))))
    | (some y : RootOutRef, (x = iota2(y))
     & ((1N +N cast(from(F)(from(RootOutRefIndex)(rootOutRefIndex(y)))))
        <= maybe((\rs : List^128(RootOut) => length(rs)))(
                 0N,
                 lookup(rootOutRefTime(y), roots(R))))).


def spendingInputExists : Rollup -> SpendIn -> Prop
  := \R : Rollup => \i : SpendIn
  => inputExists(R, from(SpendIn)(i)).


def referenceInputExists : Rollup -> RefIn -> Prop
  := \R : Rollup => \i : RefIn
  => inputExists(R, from(RefIn)(i)).


def inputsExist : Rollup -> Tx -> Prop
  := \R : Rollup
  => \t : Tx
  => (all i : N < length(spendingInputs(t)),
      spendingInputExists(R, nth(spendingInputs(t), i)))
   & (all i : N < length(referenceInputs(t)),
      referenceInputExists(R, nth(referenceInputs(t), i))).


def getTxOut : Rollup -> TxOutRef -> TxOut
  := \R : Rollup => \x : TxOutRef
  => let o : List^128(TxOut) := outputs(exists(lookup(txOutRefId(x), txs(R))));
     let i : N := cast(from(F)(from(TxOutRefIndex)(txOutRefIndex(x))));
     nth(o,i).


def isSignatory : Tx -> Address -> Prop
  := \t : Tx => \a : Address
  => let s : List^128(PubKeyHash) := getSignatories(signatories(t));
     some i : N < length(s), fromPubKeyHash(nth(s, i)) = a.


def isRelatedScriptAddress : Tx -> Address -> Prop
  := \t : Tx => \a : Address
  => let o : List^128(TxOut) := outputs(t);
     some i : N < length(o),
     just(a) = (Maybe(to(Address))(Maybe(from(ScriptAddress))
                 (Maybe(pi2)(Maybe(pi2)(scriptInfo(nth(o, i))))))).


def isAuthorizedAddress : Tx -> Address -> Prop
  := \t : Tx => \a : Address
  => isSignatory(t, a) | isRelatedScriptAddress(t, a).


def inputAddressesAreAuthorized : Rollup -> Tx -> Prop
  := \R : Rollup => \t : Tx
  => all i : N < length(spendingInputs(t)),
     let x : SpendIn := nth(spendingInputs(t), i);
     (some y : TxOutRef, some a : Address,
        (x = to(SpendIn)(iota1(y)))
      & isAuthorizedAddress(t, a)
      & (a = txOutAddress(getTxOut(R, y))))
   | (some y : RootOutRef, some a : Address,
      let os : Maybe(List^128(RootOut)) := lookup(rootOutRefTime(y), roots(R));
      let r : Address := pi1(from(RootOut)
            (nth(exists(os), cast(from(F)(from(RootOutRefIndex)(rootOutRefIndex(y)))))));
        !(isNothing(os))
      & isAuthorizedAddress(t, a)
      & (a = r)).


def valueSum : List^128(Value) -> AssetClass -> Quantity
  := \x : List^128(Value) => \k : AssetClass
  => sumListLookup(k)(List(from(Value))((x))).


def totalOutput : Tx -> AssetClass -> Quantity
  := \t : Tx => \k : AssetClass
  => valueSum(values(outputs(t)), k).


def totalInput
   : (TxId -> List^128(Value))
  -> TxId
  -> AssetClass
  -> Quantity
  := \inputValues : TxId -> List^128(Value) 
  => \t : TxId 
  => \k : AssetClass
  => valueSum(inputValues(t), k).


def txBalances
   : (TxId -> List^128(Value))
  -> List^4096(AssetClass)
  -> TxId
  -> Tx
  -> Prop
  := \inputValues : TxId -> List^128(Value)
  => \assetClasses : List^4096(AssetClass)
  => \i : TxId
  => \t : Tx
  => all j : N < length(assetClasses),
     let y : AssetClass := nth(assetClasses, j);
     let a : Z := cast(from(Quantity)(totalInput(inputValues, i, y)));
     let b : Z := maybe((\x : MintQuantity => from(MintQuantity)(x)))
                    (0Z, lookup(y, mintValue(mint(t))));
     let c : Z := cast(from(Quantity)(totalOutput(t, y)));
     (a +Z b) = c.


def spendingScriptsAcceptTx
   : (ScriptAddress -> TxId -> (ScriptSize * Steps))
  -> TxId
  -> Tx
  -> Prop
  := \scriptLimits : (ScriptAddress -> TxId -> (ScriptSize * Steps))
  => \x : TxId
  => \t : Tx
  => all i : Fin(128) < (length(outputs(t))),
     let o : TxOut := nth(outputs(t), cast(i));
     !(isNothing(scriptInfo(o)))
   | (let s : Datum * Redeemer * ScriptAddress := exists(scriptInfo(o));
      let a : ScriptAddress := pi2(pi2(s));
      let d : Datum := pi1(s);
      let r : Redeemer := pi1(pi2(s));
      let l : ScriptSize * Steps := scriptLimits(a, x);
      let c : ScriptContext := to(ScriptContext)(
            ( t
            , to(ScriptPurpose)(iota2(to(Spending)(to(TxOutRef)
                ((x, to(TxOutRefIndex)(to(F)(cast(i))))))))
            ));
      accepts(a, pi1(l), pi2(l), d, r, c)).


def mintingScriptsAcceptTx
   : (ScriptAddress -> TxId -> (ScriptSize * Steps))
  -> TxId
  -> Tx
  -> Prop
  := \scriptLimits : ScriptAddress -> TxId -> (ScriptSize * Steps)
  => \x : TxId
  => \t : Tx
  => let v : Map^128(AssetClass, MintQuantity) := mintValue(mint(t));
     let inputs : Map^8(CurrencySymbol, Datum * Redeemer)
       := mintInputsMap(mintInputs(t));
     all i : N < length(keys(v)),
     let k : AssetClass := nth(keys(v), i);
     let c : CurrencySymbol := currencySymbol(k);
     let a : ScriptAddress := to(ScriptAddress)(from(CurrencySymbol)(c));
     let ctx : ScriptContext
       := to(ScriptContext)((t, to(ScriptPurpose)(iota1(to(Minting)(c)))));
     !(isNothing(lookup(c, inputs)))
   & (let m : Datum * Redeemer := exists(lookup(c, inputs));
      let l : ScriptSize * Steps := scriptLimits(a, x);
      accepts(a, pi1(l), pi2(l), pi1(m), pi2(m), ctx)).


def scriptsAcceptTx
   : (ScriptAddress -> TxId -> (ScriptSize * Steps))
  -> TxId
  -> Tx
  -> Prop
  := \scriptLimits : (ScriptAddress -> TxId -> (ScriptSize * Steps))
  => \x : TxId
  => \t : Tx
  => spendingScriptsAcceptTx(scriptLimits, x, t)
   & mintingScriptsAcceptTx(scriptLimits, x, t).


def signatureExists : TxId -> PubKeyHash -> Prop
  := \x : TxId => \h : PubKeyHash => 0N = 0N. -- TODO: make this a free variable.

def isSignedByAllSignatories : TxId -> Tx -> Prop
  := \x : TxId => \t : Tx
  => let s : List^128(PubKeyHash) := getSignatories(signatories(t));
     all i : N < length(s), signatureExists(x, nth(s, i)).
